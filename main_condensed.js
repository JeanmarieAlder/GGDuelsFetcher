const selfId = ""
const lastId = ""
async function main(e, t) { function o(e, t) { return new Promise((o => { setTimeout((() => { o(e()) }), t) })) } const n = await async function (t = 1, n = "", a = "") { let s = a; const r = []; for (let a = 0; a < t; a++) { console.log("Fetching page", a + 1); let t = "https://www.geoguessr.com/api/v4/feed/private"; "" !== s && (t += "?paginationToken=" + s); let i = await fetch(t), c = await i.json(); if (0 === c.entries.length) { console.log("All data fetched."); break } if (r.push(...(l = JSON.stringify(c), [...l.matchAll(/\\"gameId\\":\\"([\w\d\-]*)\\",\\"gameMode\\":\\"Duels\\"/g)].map((e => e[1])))), r.includes(n)) break; p = c.entries[c.entries.length - 1].time.substring(0, 23) + "Z", s = btoa(`{"HashKey":{"S":"${e + "_activity"}"},"Created":{"S":"${p}"}}`), await o((() => console.log("Done")), 500) } var p, l; let i = r.filter(((e, t, o) => o.indexOf(e) === t)); return i.includes(n) ? i.slice(0, i.indexOf(n)) : i }(1e3, t); let a = {}; async function s(t) { const o = {}; o.id = t.gameId, o.rounds = t.currentRoundNumber, o.startDate = new Date(t.rounds[0].startTime).toLocaleString("en-US"), o.endDate = new Date(t.rounds[o.rounds - 1].endTime).toLocaleString("en-US"), o.mode = t.options.competitiveGameMode; for (let n = 0; n < 2; n++) { let s = t.teams[n]; if (s.players[0].playerId === e) { if (o.selfHp = s.health, null === s.players[0].progressChange) o.befElo = s.players[0].rating, o.aftElo = o.befElo; else { const e = s.players[0].progressChange.competitiveProgress; null === e ? (o.befElo = s.players[0].rating, o.aftElo = o.befElo) : (o.befElo = e.ratingBefore, o.aftElo = e.ratingAfter) } [o.selfDist, o.selfTtg, o.selfCountries] = r(s.players[0].guesses, t.rounds, s.roundResults, t.teams[1 - n].roundResults) } else { if (o.oppId = s.players[0].playerId, o.oppHp = s.health, o.oppElo = s.players[0].rating, [o.oppDist, o.oppTtg, _nil] = r(s.players[0].guesses, t.rounds), !a[o.oppId]) { const e = `https://www.geoguessr.com/api/v3/users/${o.oppId}`, t = await fetch(e, { credentials: "include" }); if (t.status >= 400) { o.oppName = "Deleted User", o.oppCountry = "", o.oppBanned = !0, o.oppBlueCheck = !1, o.oppCreator = !1; continue } const n = await t.json(); a[o.oppId] = n } const e = a[o.oppId]; o.oppName = e.nick, o.oppCountry = e.countryCode, o.oppBanned = e.isBanned, o.oppBluecheck = 0 != (2 & e.flair), o.oppCreator = e.isCreator } } return o } function r(e, t, o = null, n = null) { let a = 0, s = 0, r = 0, p = {}; for (const l of e) { let e = l.roundNumber - 1, i = (new Date(l.created) - new Date(t[e].startTime)) / 1e3; if (r++, a += l.distance, s += i, !o) continue; let c = t[e].panorama?.countryCode; "" !== c && (c in p || (p[c] = [0, 0, 0, 0, 0, 0]), p[c][0]++, p[c][1] += l.distance, p[c][2] += i, o[e].healthAfter >= o[e].healthBefore ? p[c][3]++ : p[c][4] += n[e].score - o[e].score, p[c][5] += o[e].score - n[e].score) } return 0 === r ? ["", ""] : [a / r, s / r, Object.entries(p).map((e => e[0] + "," + e[1].join(","))).join(";")] } const p = { id: "ID", rounds: "# Rounds", startDate: "Start Date", endDate: "End Date", selfHp: "My Health", befElo: "Start ELO", aftElo: "End ELO", selfDist: "Avg Distance", selfTtg: "Avg TTG", oppId: "Opp ID", oppHp: "Opp Health", oppElo: "Opp ELO", oppDist: "Opp Distance", oppTtg: "Opp TTG", selfCountries: "Self Countries", mode: "Game Mode", oppName: "Opp Name", oppCountry: "Opp Country", oppBanned: "Opp Banned", oppBluecheck: "Opp Bluecheck", oppCreator: "Opp Creator" }; const l = function (e, t = "\t", o = p) { let n = ""; e = [...e]; for (const a of e) { for (const e in o) n += a[e] + t; n += "\n" } return n }(await async function (e) { let t = [], n = 0; for (const a of e) { console.log(`Fetching duel #${n++} / ${e.length}`); let r = await fetch(`https://game-server.geoguessr.com/api/duels/${a}`, { credentials: "include" }); r = await r.json(); const p = await s(r); t.push(p), await o((() => null), 150) } return t }(n)); return l }
await main(selfId, lastId)
